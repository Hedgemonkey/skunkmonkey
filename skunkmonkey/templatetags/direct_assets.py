"""
Template tag for loading static assets in Django templates.
Uses manifest.json from Vite to find and include JS and CSS assets.

This is a simplified version that only searches for assets by
their name attribute in the manifest.json file, with no fallback
mechanisms or special cases.
"""
import json
import logging
import os
import time
from pathlib import Path

from django import template
from django.conf import settings
from django.utils.safestring import mark_safe

logger = logging.getLogger(__name__)
register = template.Library()

# Cache manifest data for 5 minutes in production, 10 seconds in development
MANIFEST_CACHE_TIME = 300 if not getattr(settings, 'DEBUG', False) else 10
_last_manifest_load = 0
_cached_manifest = None


@register.simple_tag
def direct_asset(name):
    """
    Load CSS and JS assets using the manifest.json generated by Vite.
    Enhanced to handle various naming patterns and asset types.

    Args:
        name: The asset name to load (identifier used in vite.config.js)
             Can be a simple name like 'profile' or include a module prefix
             like 'users/profile' or even have a file extension like
             'profile.js'

    Returns:
        HTML tags for the requested asset (CSS links and JS script tags)
    """
    # Check if Django is in DEBUG mode with dev server
    debug_mode = getattr(settings, 'DEBUG', False)
    use_dev_server = getattr(settings, 'USE_VITE_DEV_SERVER', False)

    # Normalize the asset name by stripping file extensions if present
    if name.endswith('.js') or name.endswith('.css'):
        name = name.rsplit('.', 1)[0]

    if debug_mode and use_dev_server:
        # In development with dev server, use that instead of manifest
        dev_server = getattr(
            settings, 'VITE_DEV_SERVER', 'http://localhost:5173'
        )
        return _render_dev_asset(name, dev_server)

    # Try to determine the module from the asset name if it includes a path
    module = None
    if '/' in name:
        parts = name.split('/')
        if len(parts) >= 2:
            module, name = parts[0], parts[-1]

    # Production mode - use compiled static files via manifest.json
    result = _render_prod_asset(name)

    # If nothing was found and we have a module prefix, try with
    # just the base name
    if '<!-- Asset' in result and module:
        result = _render_prod_asset(name)

    # Additional fallbacks for known naming pattern variations
    if '<!-- Asset' in result:
        # Try with camelCase
        if '-' in name:
            camel_name = ''.join(
                x.capitalize() if i > 0 else x
                for i, x in enumerate(name.split('-'))
            )
            result = _render_prod_asset(camel_name)

        # Try with kebab-case
        elif any(c.isupper() for c in name):
            kebab_name = ''.join(
                '-' + c.lower() if c.isupper() else c
                for c in name
            ).lstrip('-')
            result = _render_prod_asset(kebab_name)

    return result


def _render_dev_asset(name, dev_server):
    """
    Render asset tags using Vite dev server in development mode.

    Args:
        name: The asset name
        dev_server: URL of the Vite dev server

    Returns:
        HTML script tag pointing to the dev server
    """
    # Dev server handles all assets including CSS when requesting entry point
    html = f'<script type="module" src="{dev_server}/@vite/client"></script>\n'
    client_script = f'<script type="module" src="{dev_server}/src/main.js" '
    client_script += f'data-entry="{name}"></script>'
    html += client_script
    return mark_safe(html)


def _render_prod_asset(name):
    """
    Render asset tags using compiled files via manifest.json.

    Args:
        name: The asset name to find in the manifest

    Returns:
        HTML tags for the CSS and JS files or empty string if not found
    """
    # Get the base URL for static assets
    static_url = getattr(settings, 'STATIC_URL', '/static/')

    # Load the manifest from static directory
    manifest_data = _load_manifest()

    if not manifest_data:
        # If manifest couldn't be loaded, log an error and return empty
        logger.error(f"No manifest data found for asset '{name}'")
        return mark_safe(
            f"<!-- Asset '{name}' not found: manifest.json missing -->")

    # Find the asset by name in the manifest
    asset_entry = _find_asset_by_name(manifest_data, name)

    if not asset_entry:
        # Log that the asset wasn't found
        logger.error(f"Asset '{name}' not found in manifest.json")
        return mark_safe(f"<!-- Asset '{name}' not found in manifest.json -->")

    # Generate HTML for the found asset
    return _generate_asset_html(asset_entry, static_url)


def _load_manifest():
    """
    Load the manifest.json file from static or staticfiles directory.
    Uses caching to avoid reloading the file on every request.

    Returns:
        dict: The manifest data or None if not found/invalid
    """
    global _last_manifest_load, _cached_manifest

    # Return cached manifest if it's still valid
    now = time.time()
    if _cached_manifest and now - _last_manifest_load < MANIFEST_CACHE_TIME:
        return _cached_manifest

    # Define potential manifest locations to check
    manifest_paths = [
        Path(settings.BASE_DIR) / 'static' / 'manifest.json',
        Path(settings.BASE_DIR) / 'staticfiles' / 'manifest.json',
        Path(settings.BASE_DIR) / 'static' / '.vite' / 'manifest.json'
    ]

    # Try each path
    for path in manifest_paths:
        try:
            if path.exists():
                with open(path, 'r') as file:
                    _cached_manifest = json.load(file)
                    _last_manifest_load = now
                    logger.debug(f"Loaded manifest from {path}")
                    return _cached_manifest
        except (IOError, json.JSONDecodeError) as e:
            logger.warning(f"Failed to load manifest from {path}: {e}")
            continue

    logger.warning("No valid manifest.json found")
    return None


def _find_asset_by_name(manifest, name):
    """
    Find an asset entry in the manifest using multiple strategies.
    First tries by exact 'name' attribute match, then by key pattern matching,
    and finally by path pattern matching for better flexibility.

    Args:
        manifest: The loaded manifest.json data
        name: The name of the asset to find

    Returns:
        dict: The asset entry or None if not found
    """
    # 1. Search for entry with exact matching name attribute
    for key, entry in manifest.items():
        if isinstance(entry, dict) and entry.get('name') == name:
            logger.debug(f"Found asset '{name}' by exact name attribute")
            return entry

    # 2. Try normalized name matching with common prefixes
    normalized_name = name.replace('-', '').replace('_', '').lower()

    for entry in manifest.values():
        if isinstance(entry, dict) and 'name' in entry:
            entry_name = (
                entry['name'].replace('-', '').replace('_', '').lower()
            )
            if entry_name == normalized_name:
                logger.debug(
                    f"Found asset '{name}' by normalized name {entry_name}"
                )
                return entry

    # 3. Try to match based on file path segments or src attribute
    # This helps with finding files in subdirectories
    for key, entry in manifest.items():
        if not isinstance(entry, dict):
            continue

        # Check if the file path contains our asset name
        if 'file' in entry and name.lower() in entry['file'].lower():
            logger.debug(f"Found asset '{name}' in file path: {entry['file']}")
            return entry

        # Also check src attribute if present
        if 'src' in entry and name.lower() in entry['src'].lower():
            logger.debug(f"Found asset '{name}' in src path: {entry['src']}")
            return entry

    # 4. Try common module directory patterns if name might be a module path
    module_patterns = [
        'js/', 'css/', 'staff/', 'users/', 'shop/', 'products/', 'core/'
    ]
    for pattern in module_patterns:
        module_key = f"{pattern}{name}"
        for key, entry in manifest.items():
            if (
                isinstance(entry, dict)
                and (
                    (
                        'file' in entry
                        and module_key.lower() in entry['file'].lower()
                    )
                    or (
                        'src' in entry
                        and module_key.lower() in entry['src'].lower()
                    )
                )
            ):
                logger.debug(
                    f"Found asset '{name}' via module pattern: {module_key}"
                )
                return entry

    # If we get here, the asset wasn't found
    logger.warning(f"Asset '{name}' not found in manifest.json by any method")
    return None


def _generate_asset_html(asset_entry, static_url):
    """
    Generate HTML tags for CSS and JS files in an asset entry.
    Includes better handling for various asset types and dependencies.

    Args:
        asset_entry: The asset entry from the manifest
        static_url: The base URL for static assets

    Returns:
        str: HTML for the asset's CSS and JS files and their dependencies
    """
    html_parts = []
    processed_files = set()  # Track processed files to avoid duplicates

    # Add CSS links if present
    if 'css' in asset_entry and asset_entry['css']:
        for css_file in asset_entry['css']:
            if css_file in processed_files:
                continue

            css_url = f"{static_url}{css_file}"
            processed_files.add(css_file)

            # Check for integrity hash
            integrity = ""
            if (
                "integrity" in asset_entry
                and css_file in asset_entry["integrity"]
            ):
                integrity = (
                    f' integrity="{asset_entry["integrity"][css_file]}"'
                    f' crossorigin="anonymous"'
                )

            html_parts.append(
                f'<link rel="stylesheet" href="{css_url}"{integrity}>'
            )

    # Add JS script if present
    if 'file' in asset_entry:
        js_file = asset_entry['file']
        if js_file not in processed_files:
            js_url = f"{static_url}{js_file}"
            processed_files.add(js_file)

            # Check for integrity hash
            integrity = ""
            if (
                'integrity' in asset_entry
                and js_file in asset_entry['integrity']
            ):
                integrity = (
                    f' integrity="{asset_entry["integrity"][js_file]}"'
                    f' crossorigin="anonymous"'
                )

            html_parts.append(
                f'<script type="module" src="{js_url}"{integrity}></script>'
            )

    # Process any imports recursively if needed
    # This ensures that all dependencies are loaded
    if 'imports' in asset_entry and asset_entry['imports']:
        # We're only checking one level of imports to avoid circular references
        # and because most dependencies are already bundled by Vite
        for import_name in asset_entry['imports']:
            # Remove any hash from the import name
            import_base = import_name.split('.')[0]
            if import_base in processed_files:
                continue

            processed_files.add(import_base)

    return mark_safe('\n'.join(html_parts))


@register.simple_tag
def debug_manifest():
    """
    Display asset system debug information including manifest.json contents.

    Returns:
        HTML with debugging information about the asset system
    """
    # Check deployment environment
    on_heroku = 'DATABASE_URL' in os.environ
    environment = "Heroku" if on_heroku else "Local development"

    # Load manifest
    manifest_data = _load_manifest()

    # Check cache status
    cache_age = (
        time.time() - _last_manifest_load if _last_manifest_load > 0 else 0
    )
    cache_status = (
        "Using cached manifest" if cache_age > 0 else "Fresh manifest load"
    )
    cache_time_left = (
        MANIFEST_CACHE_TIME - cache_age if cache_age > 0 else 0
    )

    # Build the debug output
    output = [
        '<div style="font-family: sans-serif; padding: 15px; '
        'border: 1px solid #ddd; border-radius: 5px; '
        'background-color: #f9f9f9;">',
        "<h3>Asset System Debug</h3>",
        f"<p><strong>Environment:</strong> {environment}</p>",
        f"<p><strong>Cache:</strong> {cache_status} "
        f"(expires in {cache_time_left:.1f}s)</p>",
        "<h4>Manifest Status:</h4>",
    ]

    if manifest_data:
        # Count asset types
        js_files = sum(
            1 for v in manifest_data.values()
            if (
                isinstance(v, dict)
                and 'file' in v
                and v['file'].endswith('.js')
            )
        )
        css_files = sum(
            1 for v in manifest_data.values()
            if (
                isinstance(v, dict)
                and 'css' in v
                and v['css']
            )
        )

        # Get all unique asset names
        asset_names = []
        for key, value in manifest_data.items():
            if (
                isinstance(value, dict)
                and 'name' in value
                and value['name'] not in asset_names
            ):
                asset_names.append(value['name'])

        output.extend([
            f"<p>✅ <strong>Manifest loaded</strong> with "
            f"{len(manifest_data)} entries</p>",
            "<p><strong>Summary:</strong></p>",
            "<ul>",
            f"<li>Total entries: {len(manifest_data)}</li>",
            f"<li>JS files: {js_files}</li>",
            f"<li>CSS files: {css_files}</li>",
            f"<li>Named assets: {len(asset_names)}</li>",
            "</ul>",
            "<h4>Available Asset Names:</h4>",
            '<div style="max-height: 150px; overflow-y: auto; '
            'font-family: monospace; background: #f3f3f3; padding: 10px; '
            'border: 1px solid #ddd; margin-bottom: 15px;">',
            ", ".join(sorted(asset_names)),
            "</div>",
            "<h4>Sample Manifest Entries:</h4>",
            "<pre style='background-color: #f8f9fa; padding: 10px; "
            "border-radius: 5px; font-size: 0.8em; max-height: 200px; "
            "overflow: auto;'>"
        ])

        # Show first 3 entries as a sample
        sample_entries = list(manifest_data.items())[:3]
        for key, value in sample_entries:
            output.append(f"{key}: {json.dumps(value, indent=2)}")

        output.append("</pre>")
    else:
        output.append(
            "<p>❌ <strong>Manifest not found or invalid</strong></p>")

        # Check potential manifest paths
        manifest_paths = [
            Path(settings.BASE_DIR) / 'static' / 'manifest.json',
            Path(settings.BASE_DIR) / 'staticfiles' / 'manifest.json',
            Path(settings.BASE_DIR) / 'static' / '.vite' / 'manifest.json'
        ]

        output.append("<p>Searched in:</p><ul>")
        for path in manifest_paths:
            status = "✅ Exists" if path.exists() else "❌ Not found"
            output.append(f"<li>{path}: {status}</li>")
        output.append("</ul>")

    output.append("</div>")
    return mark_safe("\n".join(output))
