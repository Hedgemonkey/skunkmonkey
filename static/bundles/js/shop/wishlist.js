/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./shop/static/js/shop/wishlist-initializer.js":
/*!*****************************************************!*\
  !*** ./shop/static/js/shop/wishlist-initializer.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   initWishlist: () => (/* binding */ initWishlist)\n/* harmony export */ });\n/* harmony import */ var _wishlist_manager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wishlist-manager.js */ \"./shop/static/js/shop/wishlist-manager.js\");\n/**\n * Wishlist Initializer\n * Bootstraps the wishlist functionality when the page loads\n */\n\n\n\n/**\n * Initialize wishlist functionality\n */\nfunction initWishlist() {\n  // The wishlist manager is automatically initialized on import,\n  // but we can perform additional initialization here if needed\n\n  // Check if we're on the wishlist page\n  var isWishlistPage = window.location.pathname.includes('/wishlist/');\n  if (isWishlistPage) {\n    // Initialize special wishlist page functionality\n    initWishlistPage();\n  }\n  console.log('[WishlistInitializer] Wishlist functionality initialized');\n}\n\n/**\n * Initialize wishlist page specific functionality\n */\nfunction initWishlistPage() {\n  // Add any wishlist page specific functionality here\n  console.log('[WishlistInitializer] Wishlist page specific functionality initialized');\n\n  // Example: Add empty wishlist check\n  var wishlistItems = document.querySelectorAll('.wishlist-item, .product-card');\n  if (wishlistItems.length === 0) {\n    var container = document.querySelector('.container main, .wishlist-container');\n    if (container) {\n      container.innerHTML = \"\\n                <div class=\\\"empty-wishlist alert alert-info text-center my-5\\\">\\n                    <i class=\\\"fas fa-heart-broken mb-3\\\" style=\\\"font-size: 3rem;\\\"></i>\\n                    <h3>Your wishlist is empty</h3>\\n                    <p class=\\\"mb-3\\\">You haven't added any products to your wishlist yet.</p>\\n                    <a href=\\\"/shop/\\\" class=\\\"btn btn-primary\\\">\\n                        <i class=\\\"fas fa-shopping-bag me-2\\\"></i>Browse Products\\n                    </a>\\n                </div>\\n            \";\n    }\n  }\n}\n\n// Initialize when the DOM is fully loaded\ndocument.addEventListener('DOMContentLoaded', initWishlist);\n\n// Also export the init function to allow manual initialization\n\n\n//# sourceURL=webpack://skunkmonkey/./shop/static/js/shop/wishlist-initializer.js?");

/***/ }),

/***/ "./shop/static/js/shop/wishlist-manager.js":
/*!*************************************************!*\
  !*** ./shop/static/js/shop/wishlist-manager.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _static_js_api_client_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../../static/js/api-client.js */ \"./static/js/api-client.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * Wishlist Manager\n * Handles wishlist functionality for the shop\n */\n\n\n\n/**\n * WishlistManager class for handling wishlist functionality\n */\nvar WishlistManager = /*#__PURE__*/function () {\n  /**\n   * Initialize the WishlistManager\n   */\n  function WishlistManager() {\n    _classCallCheck(this, WishlistManager);\n    // Initialize properties BEFORE calling methods that use them\n    this.toastQueue = []; // Queue for storing toast notifications\n    this.processingToast = false; // Flag to track if a toast is currently being processed\n    this.debug = true; // Enable debug logging\n    this.wishlistItems = new Set(); // Store wishlist item IDs <-- Initialize this FIRST\n\n    this.initialize(); // Now call initialize, which uses this.wishlistItems\n  }\n\n  /**\n   * Initialize the wishlist manager with error handling\n   */\n  return _createClass(WishlistManager, [{\n    key: \"initialize\",\n    value: function initialize() {\n      var _this = this;\n      try {\n        // Initialize the wishlist items set from any data available\n        this.initializeWishlistItems();\n        this.initEventListeners();\n        this.checkSweetAlert2Availability();\n\n        // Process any queued toasts once SweetAlert2 is available\n        document.addEventListener('swal2-initialized', function () {\n          _this.log('SweetAlert2 initialized event received, processing queued toasts');\n          _this.processToastQueue();\n        });\n      } catch (error) {\n        console.error('Error initializing Wishlist Manager:', error);\n      }\n    }\n\n    /**\n     * Initialize the wishlist items set from the DOM\n     */\n  }, {\n    key: \"initializeWishlistItems\",\n    value: function initializeWishlistItems() {\n      var _this2 = this;\n      // Try to get wishlist count from the DOM\n      var wishlistCountElements = document.querySelectorAll('.wishlist-count');\n      if (wishlistCountElements.length > 0) {\n        var count = parseInt(wishlistCountElements[0].textContent, 10);\n        this.log('Initial wishlist count:', count);\n      }\n\n      // Try to collect wishlist product IDs from data attributes or classes\n      document.querySelectorAll('.remove-wishlist-btn, .wishlist-btn.active').forEach(function (btn) {\n        var productId = btn.dataset.productId;\n        if (productId) {\n          _this2.wishlistItems.add(productId);\n          _this2.log('Added product to initial wishlist set:', productId);\n        }\n      });\n\n      // Look for wishlist product IDs in a data attribute on the body or a hidden input\n      var wishlistDataElement = document.getElementById('wishlist-data');\n      if (wishlistDataElement) {\n        try {\n          var wishlistData = JSON.parse(wishlistDataElement.value);\n          if (Array.isArray(wishlistData)) {\n            wishlistData.forEach(function (id) {\n              return _this2.wishlistItems.add(id.toString());\n            });\n            this.log('Initialized wishlist items from data element:', wishlistData);\n          }\n        } catch (e) {\n          console.error('Error parsing wishlist data:', e);\n        }\n      }\n      this.log('Initialized wishlist items:', _toConsumableArray(this.wishlistItems));\n    }\n\n    /**\n     * Log debug messages if debug mode is enabled\n     * @param {...any} args - Arguments to log\n     */\n  }, {\n    key: \"log\",\n    value: function log() {\n      if (this.debug) {\n        var _console;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        (_console = console).log.apply(_console, ['[WishlistManager]'].concat(args));\n      }\n    }\n\n    /**\n     * Check if SweetAlert2 is available and log the result\n     */\n  }, {\n    key: \"checkSweetAlert2Availability\",\n    value: function checkSweetAlert2Availability() {\n      var _this3 = this;\n      if (typeof window.Swal !== 'undefined') {\n        this.log('SweetAlert2 is available for WishlistManager.');\n        // Dispatch an event to signal SweetAlert2 is available\n        document.dispatchEvent(new Event('swal2-initialized'));\n      } else {\n        console.warn('SweetAlert2 is not available for WishlistManager. Toast notifications will fall back to alerts.');\n        // Set up a listener to check again when main.js might have loaded SweetAlert2\n        window.addEventListener('load', function () {\n          setTimeout(function () {\n            if (typeof window.Swal !== 'undefined') {\n              _this3.log('SweetAlert2 became available after window load');\n              document.dispatchEvent(new Event('swal2-initialized'));\n            } else {\n              // Try to load SweetAlert2 dynamically as a last resort\n              _this3.loadSweetAlert2Dynamically();\n            }\n          }, 500);\n        });\n      }\n    }\n\n    /**\n     * Try to load SweetAlert2 dynamically if it's not available\n     */\n  }, {\n    key: \"loadSweetAlert2Dynamically\",\n    value: function loadSweetAlert2Dynamically() {\n      var _this4 = this;\n      if (typeof window.Swal === 'undefined') {\n        this.log('Attempting to load SweetAlert2 dynamically');\n        var script = document.createElement('script');\n        script.src = 'https://cdn.jsdelivr.net/npm/sweetalert2@11';\n        script.onload = function () {\n          _this4.log('SweetAlert2 loaded dynamically');\n          document.dispatchEvent(new Event('swal2-initialized'));\n        };\n        script.onerror = function (e) {\n          console.error('Failed to load SweetAlert2 dynamically:', e);\n        };\n        document.head.appendChild(script);\n      }\n    }\n\n    /**\n     * Initialize event listeners for wishlist buttons\n     */\n  }, {\n    key: \"initEventListeners\",\n    value: function initEventListeners() {\n      var _this5 = this;\n      // Use a single unified selector for all wishlist buttons\n      var wishlistBtnSelector = '.wishlist-btn, .add-to-wishlist-btn, .remove-wishlist-btn';\n\n      // Handle existing buttons\n      document.querySelectorAll(wishlistBtnSelector).forEach(function (btn) {\n        if (!btn.hasAttribute('data-event-bound')) {\n          btn.setAttribute('data-event-bound', 'true');\n          btn.addEventListener('click', function (e) {\n            e.preventDefault();\n            _this5.handleWishlistToggle(e);\n          });\n        }\n      });\n\n      // Use delegation for future buttons\n      document.addEventListener('click', function (event) {\n        var toggleBtn = event.target.closest(wishlistBtnSelector);\n        if (toggleBtn && !toggleBtn.hasAttribute('data-event-bound')) {\n          // Check if this specific button already has a direct listener to avoid double handling\n          if (!toggleBtn.getAttribute('data-event-bound')) {\n            toggleBtn.setAttribute('data-event-bound', 'true'); // Mark for delegation handling\n            // Add the listener directly here as well, ensures it works even if mutation observer misses it\n            toggleBtn.addEventListener('click', function (e) {\n              e.preventDefault();\n              _this5.handleWishlistToggle(e);\n            });\n            // Trigger the handler immediately for this click\n            _this5.handleWishlistToggle(event);\n            event.preventDefault();\n          }\n        }\n      });\n\n      // Add a mutation observer to handle dynamically added buttons\n      this.setupMutationObserver();\n      this.log('Wishlist event listeners initialized');\n    }\n\n    /**\n     * Setup mutation observer to watch for dynamically added buttons\n     */\n  }, {\n    key: \"setupMutationObserver\",\n    value: function setupMutationObserver() {\n      var _this6 = this;\n      var wishlistBtnSelector = '.wishlist-btn:not([data-event-bound]), .add-to-wishlist-btn:not([data-event-bound]), .remove-wishlist-btn:not([data-event-bound])';\n      var observer = new MutationObserver(function (mutations) {\n        mutations.forEach(function (mutation) {\n          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n            mutation.addedNodes.forEach(function (node) {\n              if (node.nodeType === Node.ELEMENT_NODE) {\n                // Check if the added node itself is a button\n                if (node.matches(wishlistBtnSelector)) {\n                  _this6.bindWishlistButtonListener(node);\n                }\n                // Check for buttons within the added node\n                var wishlistBtns = node.querySelectorAll(wishlistBtnSelector);\n                wishlistBtns.forEach(function (btn) {\n                  _this6.bindWishlistButtonListener(btn);\n                });\n              }\n            });\n          }\n        });\n      });\n      observer.observe(document.body, {\n        childList: true,\n        subtree: true\n      });\n      this.log('Mutation observer set up for wishlist buttons.');\n    }\n\n    /**\n    * Binds the click listener to a wishlist button if not already bound.\n    * @param {HTMLElement} btn - The button element.\n    */\n  }, {\n    key: \"bindWishlistButtonListener\",\n    value: function bindWishlistButtonListener(btn) {\n      var _this7 = this;\n      if (!btn.hasAttribute('data-event-bound')) {\n        btn.setAttribute('data-event-bound', 'true');\n        btn.addEventListener('click', function (e) {\n          e.preventDefault();\n          _this7.handleWishlistToggle(e);\n        });\n        this.log('Bound listener to dynamically added button:', btn);\n      }\n    }\n\n    /**\n     * Handle toggling an item in the wishlist\n     * Handle toggling an item in the wishlist.\n     * REVISED: Stores original content, restores in finally.\n     * @param {Event} event - The click event\n     */\n  }, {\n    key: \"handleWishlistToggle\",\n    value: function handleWishlistToggle(event) {\n      var _this8 = this;\n      var button = event.currentTarget || event.target.closest('.wishlist-btn, .add-to-wishlist-btn, .remove-wishlist-btn');\n      if (!button) {\n        this.log('Wishlist toggle handler called but no button found.');\n        return;\n      }\n\n      // Prevent multiple rapid clicks\n      if (button.classList.contains('disabled')) {\n        this.log('Button already processing, ignoring click.');\n        return;\n      }\n      var productId = button.dataset.productId;\n      if (!productId) {\n        console.error(\"Wishlist button missing data-product-id:\", button);\n        this.showToast('Error', 'Product ID missing.', 'error');\n        return; // Stop if no product ID\n      }\n      var productName = button.dataset.productName || 'Product';\n      var isCurrentlyInWishlist = this.wishlistItems.has(productId);\n      this.log(\"Toggling product \".concat(productId, \": Currently in Wishlist? \").concat(isCurrentlyInWishlist));\n\n      // --- Store original content BEFORE showing spinner ---\n      var originalContent = button.innerHTML;\n      var originalDisabledState = button.disabled; // Store original disabled state\n\n      // Show spinner and disable\n      button.innerHTML = '<span class=\"spinner-border spinner-border-sm\" role=\"status\" aria-hidden=\"true\"></span>';\n      button.disabled = true; // Use disabled attribute\n      button.classList.add('disabled'); // Keep class for styling\n\n      var url = \"/shop/wishlist/toggle/\".concat(productId, \"/\");\n      this.log('POSTing to:', url);\n      _static_js_api_client_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(url, {\n        product_id: productId\n      }).then(function (response) {\n        // ... (Keep the .then() logic for parsing, determining final state, updating Set, showing toast, removing item) ...\n        _this8.log('Raw response:', response);\n        var data;\n        try {\n          if (_typeof(response) === 'object' && response !== null) data = response;else if (typeof response === 'string' && response.trim() !== '') data = JSON.parse(response);else throw new Error('Invalid or empty response');\n        } catch (error) {\n          console.error('Parse error:', error, 'Raw:', response);\n          _this8.showToast('Error', 'Received invalid data.', 'error');\n          // Return an object indicating error for finally block\n          return {\n            finalState: isCurrentlyInWishlist,\n            errorOccurred: true\n          };\n        }\n        var finalIsInWishlist = isCurrentlyInWishlist;\n        var actionSucceeded = false;\n        if (typeof data.success === 'boolean' && data.success) {\n          actionSucceeded = true;\n          // Determine final state based on server response\n          if (data.isInWishlist !== undefined) {\n            finalIsInWishlist = data.isInWishlist;\n          } else if (data.added !== undefined) {\n            finalIsInWishlist = data.added;\n          } else if (data.removed !== undefined) {\n            finalIsInWishlist = !data.removed;\n          } else {\n            // Fallback if server doesn't provide state (less ideal)\n            finalIsInWishlist = !isCurrentlyInWishlist;\n            _this8.log('Warning: Server response did not explicitly state added/removed/isInWishlist status. Inferring state.');\n          }\n          _this8.log('API Success. Final state:', finalIsInWishlist);\n          // Update local set\n          if (finalIsInWishlist) _this8.wishlistItems.add(productId);else _this8.wishlistItems[\"delete\"](productId);\n          _this8.log('Updated local Set:', _toConsumableArray(_this8.wishlistItems));\n\n          // Show toast\n          var actionType = finalIsInWishlist ? 'Added to' : 'Removed from';\n          _this8.showToast(\"\".concat(actionType, \" Wishlist\"), data.message || \"\".concat(productName, \" \").concat(actionType.toLowerCase(), \" wishlist.\"), finalIsInWishlist ? 'success' : 'info');\n\n          // Update global count if provided\n          if (data.wishlist_count !== undefined) {\n            _this8.updateWishlistCount(data.wishlist_count);\n          }\n\n          // Handle removal from wishlist page\n          if (!finalIsInWishlist && window.location.pathname.includes('/wishlist/')) {\n            _this8.removeItemFromWishlistPage(button);\n          }\n        } else {\n          actionSucceeded = false;\n          _this8.log('API Failure:', data.message || data.error || 'Unknown error.');\n          _this8.showToast('Error', data.message || data.error || 'Failed to update.', 'error');\n        }\n        // Return state for finally block\n        return {\n          finalState: finalIsInWishlist,\n          errorOccurred: !actionSucceeded\n        };\n      })[\"catch\"](function (error) {\n        // ... (Keep the .catch() logic for logging, showing error toast) ...\n        console.error('API Call Error:', error);\n        var errorMessage = 'Update failed. Check connection.';\n        if (error && _typeof(error) === 'object') {\n          errorMessage = error.message || error.response && error.response.data && (error.response.data.detail || error.response.data.error) || errorMessage;\n        } else if (typeof error === 'string') {\n          errorMessage = error;\n        }\n        _this8.showToast('Error', errorMessage, 'error');\n        // Return state for finally block\n        return {\n          finalState: isCurrentlyInWishlist,\n          errorOccurred: true\n        };\n      })[\"finally\"](function () {\n        // Removed the result parameter as it's not reliably passed from catch/then in all scenarios\n        // --- RELIABLE SPINNER REMOVAL ---\n        // Always get the definitive state from the Set *inside* finally\n        var finalState = _this8.wishlistItems.has(productId);\n        _this8.log(\"Finally block. Definitive final state from Set: \".concat(finalState, \". Restoring button \").concat(productId, \".\"));\n        var buttonsToRestore = document.querySelectorAll(\".wishlist-btn[data-product-id=\\\"\".concat(productId, \"\\\"], .add-to-wishlist-btn[data-product-id=\\\"\").concat(productId, \"\\\"], .remove-wishlist-btn[data-product-id=\\\"\").concat(productId, \"\\\"]\"));\n        buttonsToRestore.forEach(function (btn) {\n          // 1. Restore original content if it's currently showing ONLY the spinner\n          var spinner = btn.querySelector('span.spinner-border');\n          if (spinner && btn.children.length === 1 && btn.firstChild === spinner) {\n            btn.innerHTML = originalContent;\n            _this8.log(\"Restored original content for button:\", btn);\n          } else {\n            _this8.log(\"Button content not just spinner, skipping content restore for:\", btn);\n          }\n\n          // 2. Remove disabled state/class\n          btn.disabled = originalDisabledState; // Restore original disabled property\n          btn.classList.remove('disabled', 'wishlist-btn-active'); // Remove active class too\n\n          // 3. Update visual state (icon, classes) AFTER restoring content/enabled state\n          _this8.updateWishlistButtonVisualState(btn, finalState); // Use definitive finalState from Set\n        });\n\n        // Update global count based on final Set size\n        _this8.updateWishlistCount(_this8.wishlistItems.size);\n        _this8.log(\"Finished processing toggle for product \".concat(productId, \".\"));\n      });\n    }\n\n    /**\n     * Update all buttons for a specific product ID to reflect the current wishlist state.\n     * @param {string} productId - The product ID.\n     * @param {boolean} isInWishlist - The definitive state whether the product IS in the wishlist.\n     */\n  }, {\n    key: \"updateAllButtonsForProduct\",\n    value: function updateAllButtonsForProduct(productId, isInWishlist) {\n      var _this9 = this;\n      if (!productId) return;\n      this.log(\"Updating all buttons for product \".concat(productId, \" to state: \").concat(isInWishlist ? 'IN wishlist' : 'NOT in wishlist'));\n      var buttons = document.querySelectorAll(\".wishlist-btn[data-product-id=\\\"\".concat(productId, \"\\\"], \") + \".add-to-wishlist-btn[data-product-id=\\\"\".concat(productId, \"\\\"], \") + \".remove-wishlist-btn[data-product-id=\\\"\".concat(productId, \"\\\"]\"));\n      if (buttons.length === 0) {\n        this.log(\"No buttons found for product \".concat(productId, \" to update.\"));\n        return;\n      }\n      buttons.forEach(function (button) {\n        _this9.updateWishlistButtonVisualState(button, isInWishlist);\n        // Ensure button is enabled after update (might have been disabled during API call)\n        button.classList.remove('disabled', 'wishlist-btn-active');\n        // Restore original content if spinner was present (safer check)\n        var spinner = button.querySelector('.spinner-border');\n        if (spinner) {\n          // Need to know what the original content *should* be based on state\n          // Assuming simple icon or text change happens in updateWishlistButtonVisualState\n          // If original content varies wildly, this needs more complex state management\n        }\n      });\n    }\n\n    /**\n     * Updates the visual appearance (classes, icon, title, aria-label, href) of a single wishlist button.\n     * SIMPLIFIED: Only sets state based on isInWishlist, does NOT handle spinner removal or content restoration.\n     * @param {HTMLElement} button - The button element to update.\n     * @param {boolean} isInWishlist - Whether the product IS currently in the wishlist.\n     */\n  }, {\n    key: \"updateWishlistButtonVisualState\",\n    value: function updateWishlistButtonVisualState(button, isInWishlist) {\n      if (!button) return;\n      var productName = button.dataset.productName || 'this product';\n      var productId = button.dataset.productId;\n      var icon = button.querySelector('i');\n\n      // --- Update Button Classes ---\n      if (isInWishlist) {\n        button.classList.remove('add-to-wishlist-btn');\n        button.classList.add('remove-wishlist-btn', 'active');\n      } else {\n        button.classList.remove('remove-wishlist-btn', 'active');\n        button.classList.add('add-to-wishlist-btn');\n      }\n\n      // --- Update Icon Classes ---\n      if (icon) {\n        // Ensure correct icon state based on isInWishlist\n        if (isInWishlist) {\n          // ** CHANGE: Set SOLID heart as the default for \"Remove\" state **\n          icon.classList.remove('far', 'fa-heart-broken', 'fa-heart-o'); // Remove others\n          icon.classList.add('fas', 'fa-heart'); // Add SOLID heart\n        } else {\n          // For \"Add\" state: Use regular outline heart (FA5 Free)\n          icon.classList.remove('fas', 'fa-heart-broken', 'fa-heart', 'fa-heart-o'); // Remove others\n          icon.classList.add('far', 'fa-heart'); // Add outline heart\n        }\n      }\n\n      // --- Update Title and Aria-label ---\n      if (isInWishlist) {\n        button.setAttribute('title', \"Remove \".concat(productName, \" from wishlist\"));\n        button.setAttribute('aria-label', \"Remove \".concat(productName, \" from wishlist\"));\n      } else {\n        button.setAttribute('title', \"Add \".concat(productName, \" to wishlist\"));\n        button.setAttribute('aria-label', \"Add \".concat(productName, \" to wishlist\"));\n      }\n\n      // --- Always update href ---\n      if (productId) {\n        button.setAttribute('href', \"/shop/wishlist/toggle/\".concat(productId, \"/\"));\n      }\n\n      // --- Mark state as set (for observer/debugging) ---\n      button.setAttribute('data-visual-state-set', isInWishlist ? 'in' : 'out');\n\n      // --- DO NOT handle spinner/disabled here - handled in finally block ---\n      // --- DO NOT handle innerHTML restoration here - handled in finally block ---\n    }\n\n    /**\n     * Remove an item visually from the wishlist page after successful removal via API.\n     * @param {HTMLElement} button - The 'remove' button that was clicked.\n     */\n  }, {\n    key: \"removeItemFromWishlistPage\",\n    value: function removeItemFromWishlistPage(button) {\n      var _this10 = this;\n      var card = button.closest('.product-card, .wishlist-item');\n      if (!card) {\n        this.log('Could not find product card/item to remove from wishlist page.');\n        return;\n      }\n\n      // Find the most appropriate container to remove (e.g., the grid column or list item)\n      var container = card.closest('.col, .wishlist-item-container, li, div.product-entry'); // Add more selectors if needed\n      var elementToRemove = container || card; // Fallback to removing the card itself\n\n      this.log('Removing wishlist item element:', elementToRemove);\n\n      // Animate removal\n      elementToRemove.style.transition = 'opacity 0.5s ease, transform 0.5s ease, height 0.5s ease, margin 0.5s ease, padding 0.5s ease';\n      elementToRemove.style.opacity = '0';\n      elementToRemove.style.transform = 'scale(0.8)';\n      elementToRemove.style.height = '0'; // Collapse height\n      elementToRemove.style.marginTop = '0';\n      elementToRemove.style.marginBottom = '0';\n      elementToRemove.style.paddingTop = '0';\n      elementToRemove.style.paddingBottom = '0';\n      elementToRemove.style.borderWidth = '0'; // Collapse border\n\n      setTimeout(function () {\n        elementToRemove.remove();\n        _this10.log('Wishlist item removed from DOM.');\n\n        // Check if wishlist is now empty\n        var remainingItems = document.querySelectorAll('.product-card, .wishlist-item');\n        _this10.log('Remaining wishlist items on page:', remainingItems.length);\n        if (remainingItems.length === 0) {\n          _this10.displayEmptyWishlistMessage();\n        } else {\n          // Update count just in case it wasn't updated by API response\n          _this10.updateWishlistCount(remainingItems.length);\n        }\n      }, 500); // Match animation duration\n    }\n\n    /**\n     * Displays a message indicating the wishlist is empty.\n     */\n  }, {\n    key: \"displayEmptyWishlistMessage\",\n    value: function displayEmptyWishlistMessage() {\n      this.log('Displaying empty wishlist message.');\n      var mainContent = document.querySelector('.container main, .wishlist-container, .content-section, #main-content'); // More robust selector\n      if (mainContent) {\n        // Clear existing content within the main area *carefully*\n        // Avoid wiping out headers/footers if they are inside the selected container\n        var wishlistGrid = mainContent.querySelector('.row.wishlist-items, #wishlist-items-container'); // Target specific container if possible\n        var containerToEmpty = wishlistGrid || mainContent;\n        containerToEmpty.innerHTML = \"\\n                <div class=\\\"empty-wishlist alert alert-info text-center my-5 col-12\\\">\\n                    <i class=\\\"fas fa-heart-broken fa-3x mb-3\\\"></i>\\n                    <h3 class=\\\"alert-heading\\\">Your Wishlist is Empty</h3>\\n                    <p class=\\\"lead mb-4\\\">You haven't added any products yet. Start exploring!</p>\\n                    <a href=\\\"/shop/\\\" class=\\\"btn btn-primary btn-lg\\\">\\n                        <i class=\\\"fas fa-shopping-bag me-2\\\"></i>Browse Products\\n                    </a>\\n                </div>\\n            \";\n        // Ensure count is zero\n        this.updateWishlistCount(0);\n      } else {\n        this.log('Could not find main content area to display empty wishlist message.');\n      }\n    }\n\n    /**\n     * Update the wishlist count in the UI\n     * @param {number} count - The new wishlist count\n     */\n  }, {\n    key: \"updateWishlistCount\",\n    value: function updateWishlistCount(count) {\n      if (count !== undefined && !isNaN(count)) {\n        this.log('Updating wishlist count UI elements to:', count);\n        document.querySelectorAll('.wishlist-count').forEach(function (element) {\n          element.textContent = count;\n          // Optional: Add animation or visual feedback on change\n          element.classList.add('animate__animated', 'animate__bounceIn');\n          element.onanimationend = function () {\n            return element.classList.remove('animate__animated', 'animate__bounceIn');\n          };\n\n          // Hide/show container based on count\n          var counterContainer = element.closest('.wishlist-count-container') || element; // Use element itself if no specific container\n          if (counterContainer) {\n            counterContainer.style.display = count === 0 ? 'none' : ''; // Use style.display for better control\n          }\n        });\n      } else {\n        this.log('Invalid count received for UI update:', count);\n      }\n    }\n\n    /**\n     * Add a toast to the queue and process it\n     * @param {string} title - The notification title\n     * @param {string} message - The notification message (can be HTML).\n     * @param {string} type - Notification type ('success', 'error', 'warning', 'info', 'question').\n     */\n  }, {\n    key: \"showToast\",\n    value: function showToast(title, message) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'info';\n      this.log('Queueing toast:', {\n        title: title,\n        message: message,\n        type: type\n      });\n      this.toastQueue.push({\n        title: title,\n        message: message,\n        type: type\n      });\n      if (!this.processingToast) {\n        this.processToastQueue();\n      }\n    }\n\n    /**\n     * Process the next toast notification in the queue.\n     */\n  }, {\n    key: \"processToastQueue\",\n    value: function processToastQueue() {\n      var _this11 = this;\n      if (this.toastQueue.length === 0) {\n        this.processingToast = false;\n        this.log('Toast queue empty.');\n        return;\n      }\n      this.processingToast = true;\n      var toastToShow = this.toastQueue.shift();\n      this.log('Processing toast from queue:', toastToShow);\n      this.displayToast(toastToShow.title, toastToShow.message, toastToShow.type)[\"finally\"](function () {\n        // Process next toast after a short delay to prevent rapid-fire toasts\n        setTimeout(function () {\n          _this11.processToastQueue();\n        }, 300); // Adjust delay as needed\n      });\n    }\n\n    /**\n     * Display a toast notification using SweetAlert2 or fallback\n     * @param {string} title - The notification title\n     * @param {string} message - The notification message\n     * @param {string} message - The notification message (can be HTML).\n     * @param {string} type - Notification type ('success', 'error', 'warning', 'info', 'question').\n     * @returns {Promise} Resolves when the toast is displayed or fallback is shown.\n     */\n  }, {\n    key: \"displayToast\",\n    value: function displayToast(title, message, type) {\n      var _this12 = this;\n      return new Promise(function (resolve) {\n        _this12.log('Attempting to display toast:', {\n          title: title,\n          type: type\n        });\n\n        // Use global showToast if specifically defined elsewhere (e.g., in main.js)\n        if (typeof window.showToast === 'function' && window.showToast !== _this12.showToast) {\n          // Avoid recursion\n          _this12.log('Using global window.showToast function.');\n          try {\n            window.showToast(title, message, type);\n          } catch (e) {\n            console.error(\"Error calling global showToast:\", e);\n            _this12.fallbackToast(title, message); // Fallback if global fails\n          }\n          resolve(); // Assume global function handles itself\n        }\n        // Use SweetAlert2 if available\n        else if (typeof window.Swal !== 'undefined') {\n          _this12.log('Using SweetAlert2 for toast.');\n          var iconType = type === 'danger' ? 'error' : type; // Map 'danger' to 'error' if needed\n\n          window.Swal.fire({\n            title: title,\n            html: message,\n            // Allow HTML content\n            icon: iconType,\n            toast: true,\n            position: 'top-end',\n            // Common position for toasts\n            showConfirmButton: false,\n            timer: 3500,\n            // Slightly longer timer\n            timerProgressBar: true,\n            customClass: {\n              popup: 'custom-swal-toast' // Add custom class for styling\n            },\n            showCloseButton: true,\n            // Allow users to close manually\n            didOpen: function didOpen(toast) {\n              toast.style.zIndex = '9999'; // Ensure visibility\n              toast.addEventListener('mouseenter', window.Swal.stopTimer);\n              toast.addEventListener('mouseleave', window.Swal.resumeTimer);\n            }\n          }).then(resolve, resolve); // Resolve whether confirmed or timed out\n        }\n        // Fallback to standard alert\n        else {\n          _this12.log('SweetAlert2 not available, using fallback alert.');\n          _this12.fallbackToast(title, message);\n          resolve(); // Resolve after showing alert\n        }\n      });\n    }\n\n    /**\n     * Simple fallback alert mechanism.\n     */\n  }, {\n    key: \"fallbackToast\",\n    value: function fallbackToast(title, message) {\n      // Basic alert, strip HTML for safety if message might contain it\n      var cleanMessage = message.replace(/<[^>]*>/g, ''); // Basic HTML strip\n      alert(\"[\".concat(title, \"] \").concat(cleanMessage));\n    }\n  }]);\n}(); // --- Initialization ---\n// Ensure DOM is ready before initializing\nfunction initializeWishlistManager() {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', function () {\n      window.wishlistManager = new WishlistManager();\n    });\n  } else {\n    // DOM is already ready\n    window.wishlistManager = new WishlistManager();\n  }\n}\ninitializeWishlistManager();\n\n// Export the singleton instance *after* ensuring it's created\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (window.wishlistManager);\n\n//# sourceURL=webpack://skunkmonkey/./shop/static/js/shop/wishlist-manager.js?");

/***/ }),

/***/ "./static/js/ajax_helper.js":
/*!**********************************!*\
  !*** ./static/js/ajax_helper.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   makeAjaxRequest: () => (/* binding */ makeAjaxRequest)\n/* harmony export */ });\n/**\n * ajax_helper.js - Utility functions for AJAX requests\n * \n * Provides standardized AJAX request functionality with CSRF protection\n * and consistent error handling.\n */\n\n/**\n * Get the CSRF token from cookies\n * @param {string} name - Cookie name\n * @returns {string} - CSRF token value\n */\nfunction getCookie(name) {\n  var cookieValue = null;\n  if (document.cookie && document.cookie !== '') {\n    var cookies = document.cookie.split(';');\n    for (var i = 0; i < cookies.length; i++) {\n      var cookie = cookies[i].trim();\n      if (cookie.substring(0, name.length + 1) === name + '=') {\n        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n        break;\n      }\n    }\n  }\n  return cookieValue;\n}\n\n/**\n * Makes an AJAX request and returns the jqXHR object to allow aborting the request if needed\n * @param {string} url - The URL to send the request to\n * @param {string} method - The HTTP method to use (GET, POST, etc.)\n * @param {Object|FormData} data - The data to send with the request\n * @param {Function} successCallback - Called when the request succeeds\n * @param {Function} errorCallback - Called when the request fails\n * @param {boolean} abortable - Whether to return the jqXHR object for aborting (default: true)\n * @param {boolean} processData - Whether to process the data (set to false for FormData)\n * @param {string|boolean} contentType - Content type header or false to let jQuery set it\n * @returns {Object} The jqXHR object if abortable is true, otherwise undefined\n */\nfunction makeAjaxRequest(url, method, data, successCallback, errorCallback) {\n  var abortable = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n  var processData = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;\n  var contentType = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 'application/x-www-form-urlencoded; charset=UTF-8';\n  // Determine if data is FormData and set appropriate options\n  var isFormData = data instanceof FormData;\n  if (isFormData) {\n    processData = false;\n    contentType = false;\n  }\n\n  // Set up AJAX options\n  var ajaxOptions = {\n    url: url,\n    method: method,\n    data: data,\n    processData: processData,\n    contentType: contentType,\n    headers: {\n      'X-CSRFToken': getCookie('csrftoken'),\n      'X-Requested-With': 'XMLHttpRequest'\n    },\n    success: function success(response) {\n      if (typeof successCallback === \"function\") {\n        // Handle both JSON and HTML responses\n        if (typeof response === 'string' && response.trim().startsWith('<')) {\n          // If it's HTML content\n          successCallback({\n            html: response\n          });\n        } else {\n          // If it's JSON or other data\n          successCallback(response);\n        }\n      }\n    },\n    error: function error(jqXHR, textStatus, errorThrown) {\n      // Don't log aborted requests as errors\n      if (textStatus !== 'abort') {\n        console.error(\"AJAX Request failed:\", textStatus, errorThrown);\n        if (typeof errorCallback === \"function\") {\n          errorCallback(jqXHR, textStatus, errorThrown);\n        }\n      }\n    }\n  };\n\n  // Try to auto-detect the response type\n  if (url.includes('/api/') || url.endsWith('.json')) {\n    ajaxOptions.dataType = 'json';\n  }\n\n  // Make the request\n  var ajaxRequest = $.ajax(ajaxOptions);\n\n  // Return the jqXHR object if the request should be abortable\n  if (abortable) {\n    return ajaxRequest;\n  }\n}\n\n//# sourceURL=webpack://skunkmonkey/./static/js/ajax_helper.js?");

/***/ }),

/***/ "./static/js/api-client.js":
/*!*********************************!*\
  !*** ./static/js/api-client.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: () => (/* binding */ ApiClient),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _ajax_helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ajax_helper.js */ \"./static/js/ajax_helper.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n/**\n * api-client.js - Standardized API client for consistent AJAX operations\n * \n * Provides a higher-level wrapper around AJAX requests with standardized\n * error handling, response parsing, and consistent promise handling.\n */\n\n\n/**\n * API Client for consistent handling of AJAX requests\n */\nvar ApiClient = /*#__PURE__*/function () {\n  /**\n   * Create a new ApiClient instance\n   * @param {Object} options - Configuration options\n   * @param {Function} options.errorHandler - Global error handler function\n   * @param {string} options.baseUrl - Base URL for API requests\n   */\n  function ApiClient() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, ApiClient);\n    this.errorHandler = options.errorHandler || console.error;\n    this.baseUrl = options.baseUrl || '';\n    this.csrfToken = (0,_ajax_helper_js__WEBPACK_IMPORTED_MODULE_0__.getCookie)('csrftoken');\n    this.pendingRequests = [];\n  }\n\n  /**\n   * Builds a complete URL for the API request\n   * @param {string} endpoint - API endpoint\n   * @returns {string} - Complete URL\n   */\n  return _createClass(ApiClient, [{\n    key: \"buildUrl\",\n    value: function buildUrl(endpoint) {\n      // If endpoint is already a full URL, return it as is\n      if (endpoint.startsWith('http') || endpoint.startsWith('/')) {\n        return endpoint;\n      }\n\n      // Otherwise, join baseUrl and endpoint\n      return \"\".concat(this.baseUrl, \"/\").concat(endpoint).replace(/([^:]\\/)\\/+/g, '$1');\n    }\n\n    /**\n     * Make a GET request to fetch data\n     * @param {string} endpoint - API endpoint\n     * @param {Object} params - Query parameters\n     * @param {Object} options - Additional options\n     * @returns {Promise} - Promise resolving with response\n     */\n  }, {\n    key: \"get\",\n    value: function get(endpoint) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.request('GET', endpoint, params, options);\n    }\n\n    /**\n     * Make a POST request to create or update data\n     * @param {string} endpoint - API endpoint\n     * @param {Object|FormData} data - Data to send\n     * @param {Object} options - Additional options\n     * @returns {Promise} - Promise resolving with response\n     */\n  }, {\n    key: \"post\",\n    value: function post(endpoint) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.request('POST', endpoint, data, options);\n    }\n\n    /**\n     * Make a DELETE request to remove data\n     * @param {string} endpoint - API endpoint\n     * @param {Object} data - Data to send\n     * @param {Object} options - Additional options\n     * @returns {Promise} - Promise resolving with response\n     */\n  }, {\n    key: \"delete\",\n    value: function _delete(endpoint) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.request('DELETE', endpoint, data, options);\n    }\n\n    /**\n     * Make a generic request with specified method\n     * @param {string} method - HTTP method\n     * @param {string} endpoint - API endpoint\n     * @param {Object|FormData} data - Data to send\n     * @param {Object} options - Additional options\n     * @returns {Promise} - Promise resolving with response\n     */\n  }, {\n    key: \"request\",\n    value: function request(method, endpoint) {\n      var _this = this;\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var url = this.buildUrl(endpoint);\n      var abortable = options.abortable !== false;\n\n      // Determine if we should process the data (false for FormData)\n      var processData = !(data instanceof FormData);\n      var contentType = processData ? 'application/x-www-form-urlencoded; charset=UTF-8' : false;\n      return new Promise(function (resolve, reject) {\n        try {\n          var ajaxRequest = (0,_ajax_helper_js__WEBPACK_IMPORTED_MODULE_0__.makeAjaxRequest)(url, method, data, function (response) {\n            // Remove from pending requests\n            _this.removePendingRequest(ajaxRequest);\n            resolve(response);\n          }, function (jqXHR, textStatus, errorThrown) {\n            var _jqXHR$responseJSON;\n            // Remove from pending requests\n            _this.removePendingRequest(ajaxRequest);\n\n            // Create standardized error object\n            var error = {\n              status: jqXHR.status,\n              statusText: jqXHR.statusText,\n              responseJSON: jqXHR.responseJSON,\n              message: ((_jqXHR$responseJSON = jqXHR.responseJSON) === null || _jqXHR$responseJSON === void 0 ? void 0 : _jqXHR$responseJSON.error) || errorThrown || \"Request failed\"\n            };\n\n            // Call the global error handler if provided\n            if (_this.errorHandler && !options.skipGlobalErrorHandler) {\n              _this.errorHandler(error);\n            }\n            reject(error);\n          }, abortable, processData, contentType);\n\n          // Track the request if abortable\n          if (abortable && ajaxRequest) {\n            _this.pendingRequests.push(ajaxRequest);\n          }\n\n          // If there's a timeout option, handle it\n          if (options.timeout) {\n            setTimeout(function () {\n              if (ajaxRequest && ajaxRequest.readyState < 4) {\n                ajaxRequest.abort();\n                reject({\n                  message: 'Request timed out',\n                  status: 0,\n                  statusText: 'timeout'\n                });\n              }\n            }, options.timeout);\n          }\n        } catch (error) {\n          console.error(\"Error making request:\", error);\n          reject({\n            message: error.message || \"Failed to make request\",\n            error: error\n          });\n        }\n      });\n    }\n\n    /**\n     * Remove a request from the pending requests list\n     * @param {Object} request - The request to remove\n     */\n  }, {\n    key: \"removePendingRequest\",\n    value: function removePendingRequest(request) {\n      var index = this.pendingRequests.indexOf(request);\n      if (index !== -1) {\n        this.pendingRequests.splice(index, 1);\n      }\n    }\n\n    /**\n     * Abort all pending requests\n     */\n  }, {\n    key: \"abortAll\",\n    value: function abortAll() {\n      this.pendingRequests.forEach(function (request) {\n        if (request && typeof request.abort === 'function') {\n          request.abort();\n        }\n      });\n      this.pendingRequests = [];\n    }\n  }]);\n}();\n\n// Create a default instance\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new ApiClient());\n\n//# sourceURL=webpack://skunkmonkey/./static/js/api-client.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./shop/static/js/shop/wishlist-initializer.js");
/******/ 	
/******/ })()
;